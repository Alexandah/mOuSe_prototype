<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>dankest webpage</title>
    <style>
      .window {
        border: 1px solid black;
        position: absolute;
      }
    </style>
  </head>

  <body>
    <p>Hello! Here are the controls:</p>
    <ul>
      <li>j ~ down</li>
      <li>k ~ up</li>
      <li>h ~ left</li>
      <li>l ~ right</li>
      <li>t ~ new window</li>
      <li>q ~ close window</li>
      <li>Enter ~ right click</li>
      <li>Spacebar ~ left click</li>
    </ul>

    <script>
      //DOM Helpers
      function get(id) {
        return document.getElementById(id);
      }

      function getClass(className) {
        return document.getElementsByClassName(className);
      }

      function getTags(tagName) {
        return document.getElementsByTagName(tagName);
      }

      function getTag(tagName) {
        return getTags(tagName)[0];
      }

      function makeDiv(parent = document.body) {
        var div = document.createElement("div");
        parent.appendChild(div);
        return div;
      }

      function makeP(text, parent = document.body) {
        var p = document.createElement("p");
        p.appendChild(document.createTextNode(text));
        parent.appendChild(p);
        return p;
      }

      //Entities
      class Word {
        constructor(tokens, semantics, orderMatters = false) {
          this.tokens = tokens;
          this.semantics = semantics;
          this.orderMatters = orderMatters;
        }

        is(tokenSequence) {
          if (!this.orderMatters) {
            tokenSequence.forEach((t) => {
              let isInWord = this.tokens.indexOf(t) != -1;
              if (!isInWord) return false;
            });
          } else {
            if (tokenSequence.length != self.tokens.length) return false;
            tokenSequence.forEach((t, i) => {
              let isInPlace = this.tokens[i] == t;
              if (!isInPlace) return false;
            });
          }
          return true;
        }
      }

      class InputLanguage {
        constructor(tokens) {
          self.tokens = tokens;
          self.wordsWithTokens = {};
        }

        defWord(tokenSequence, semantics, orderMatters = false) {
          var key = 0;
          tokenSequence.forEach((token) => {
            key += token.charCodeAt();
          });

          var word = new Word(tokenSequence, semantics, orderMatters);

          if (!self.wordsWithTokens.hasOwnProperty(key))
            self.wordsWithTokens[key] = [word];
          else self.wordsWithTokens[key].push(word);
        }

        getWord(tokenSequence) {
          var key = 0;
          tokenSequence.forEach((token) => {
            key += token.charCodeAt();
          });

          if (!self.wordsWithTokens.hasOwnProperty(key)) return null;

          var words = self.wordsWithTokens[key];
          for (var i = 0; i < words.length; i++) {
            if (words[i].is(tokenSequence)) return words[i];
          }

          return null;
        }

        read(tokenSequence) {
          var word = this.getWord(tokenSequence);
          if (word != null) word.semantics();
        }
      }

      class DOMObject {
        constructor(varsIgnoringRender = []) {
          this.element = null;
          this.render = function () {};
          this.destroy = function () {
            this.element.parentElement.removeChild(this.element);
            Object.keys(this).forEach((k) => {
              delete this[k];
            });
          };
          return new Proxy(this, {
            set: (target, key, value) => {
              target[key] = value;
              switch (key) {
                case "element":
                  break;
                default:
                  let skipRender = varsIgnoringRender.indexOf(key) != -1;
                  if (skipRender) break;
                  this.render();
              }
              return true;
            },
          });
        }
      }

      /*DOMObject child schema:
      Class Thing extends DOMObject{
        constructor(a,b,c){
          super();
          this.a = a;
          this.b = b;
          this.c = c;
          this.element = make...(...)
          this.render = function () {
            this.element.style... = ...
            ...
          }
          this.render();
        }
      }
      */

      var nextId = 0;
      class Window extends DOMObject {
        constructor(x, y, width, height) {
          super();
          this.id = nextId++;
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.outlineColor = BLACK_OUTLINE_COLOR;
          this.element = makeDiv();
          this.element.setAttribute("class", "window");
          this.render = function () {
            this.element.style.left = this.x + "px";
            this.element.style.top = this.y + "px";
            this.element.style.width = this.width + "px";
            this.element.style.height = this.height + "px";
            this.element.style.border = "1px solid " + this.outlineColor;
          };
          this.render();
        }
      }

      //Constants
      const ORANGE_OUTLINE_COLOR = "#ffa500";
      const BLACK_OUTLINE_COLOR = "#000000";
      const GREEN_OUTLINE_COLOR = "#0FFF50";
      const DEFAULT_WINDOW_SIZE = { width: 250, height: 250 };
      const TOKENS = {
        UP: "k",
        DOWN: "j",
        LEFT: "h",
        RIGHT: "l",
        LEFT_CLICK: " ",
        RIGHT_CLICK: "Enter",
        NEW_WINDOW: "t",
        CLOSE_WINDOW: "q",
        INC: "Shift",
        DEC: "Control",
        GRAB: "g",
      };

      //Main
      var windows = {};
      var selected = null;
      var grabbed = false;

      var controls = new InputLanguage(Object.values(TOKENS));
      controls.defWord([TOKENS.UP], () => {
        jumpUp();
      });
      controls.defWord([TOKENS.DOWN], () => {
        jumpDown();
      });
      controls.defWord([TOKENS.LEFT], () => {
        jumpLeft();
      });
      controls.defWord([TOKENS.RIGHT], () => {
        jumpRight();
      });
      controls.defWord([TOKENS.GRAB], () => {
        toggleGrab();
      });
      controls.defWord([TOKENS.NEW_WINDOW], () => {
        openWindow(0, 0);
      });
      controls.defWord([TOKENS.CLOSE_WINDOW], () => {
        closeWindow(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.INC, TOKENS.UP], () => {
        expandWindowVertical(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.INC, TOKENS.DOWN], () => {
        expandWindowVertical(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.DEC, TOKENS.UP], () => {
        shrinkWindowVertical(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.DEC, TOKENS.DOWN], () => {
        shrinkWindowVertical(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.INC, TOKENS.LEFT], () => {
        expandWindowHorizontal(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.INC, TOKENS.RIGHT], () => {
        expandWindowHorizontal(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.DEC, TOKENS.LEFT], () => {
        shrinkWindowHorizontal(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.DEC, TOKENS.RIGHT], () => {
        shrinkWindowHorizontal(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.UP], () => {
        moveWindowUp(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.DOWN], () => {
        moveWindowDown(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.LEFT], () => {
        moveWindowLeft(selected);
      });
      controls.defWord([TOKENS.GRAB, TOKENS.RIGHT], () => {
        moveWindowRight(selected);
      });

      document.addEventListener("keydown", function (event) {
        event.preventDefault();
        let input = parseKeyEvent(event);
        console.log(input);
        controls.read(input);
      });

      function parseKeyEvent(event) {
        var key = event.key;
        switch (key) {
          case "Control":
          case "Shift":
          case "Alt":
            key = false;
            break;
          case TOKENS.GRAB:
            if (grabbed) key = false;
            break;
          default:
            key = key.toLowerCase();
            break;
        }
        var ctrl = event.ctrlKey ? "Control" : false;
        var alt = event.altKey ? "Alt" : false;
        var shift = event.shiftKey ? "Shift" : false;
        var currentGrabToken = grabbed ? TOKENS.GRAB : false;
        var rawInput = [key, ctrl, alt, shift, currentGrabToken];
        return rawInput.filter((x) => x);
      }

      function toggleSelected(windowToSelect) {
        if (grabbed) toggleGrab();
        if (selected != null) selected.outlineColor = BLACK_OUTLINE_COLOR;
        windowToSelect.outlineColor = GREEN_OUTLINE_COLOR;
        selected = windowToSelect;
      }
      function toggleGrab() {
        if (selected != null) {
          grabbed = !grabbed;
          if (grabbed) selected.outlineColor = ORANGE_OUTLINE_COLOR;
          else selected.outlineColor = GREEN_OUTLINE_COLOR;
        }
      }

      function getWindowClosestToSelectedFrom(windows) {
        var closest = null;
        var closestDistance = Infinity;
        windows.forEach((window) => {
          var distance =
            Math.abs(window.x - selected.x) + Math.abs(window.y - selected.y);
          if (distance < closestDistance) {
            closest = window;
            closestDistance = distance;
          }
        });
        if (closest == null) return selected;
        else return closest;
      }

      function jumpUp() {
        if (selected != null) {
          var windowsAbove = Object.values(windows).filter(
            (window) => window.y < selected.y
          );
          var jumpTo = getWindowClosestToSelectedFrom(windowsAbove);
          toggleSelected(selected);
          toggleSelected(jumpTo);
        }
      }
      function jumpDown() {
        if (selected != null) {
          var windowsBelow = Object.values(windows).filter(
            (window) => window.y > selected.y
          );
          var jumpTo = getWindowClosestToSelectedFrom(windowsBelow);
          toggleSelected(selected);
          toggleSelected(jumpTo);
        }
      }
      function jumpLeft() {
        if (selected != null) {
          var windowsLeft = Object.values(windows).filter(
            (window) => window.x < selected.x
          );
          var jumpTo = getWindowClosestToSelectedFrom(windowsLeft);
          toggleSelected(selected);
          toggleSelected(jumpTo);
        }
      }
      function jumpRight() {
        if (selected != null) {
          var windowsRight = Object.values(windows).filter(
            (window) => window.x > selected.x
          );
          var jumpTo = getWindowClosestToSelectedFrom(windowsRight);
          toggleSelected(selected);
          toggleSelected(jumpTo);
        }
      }

      function expandWindowHorizontal(windowToChange) {
        windowToChange.width *= 2;
      }
      function expandWindowVertical(windowToChange) {
        windowToChange.height *= 2;
      }
      function shrinkWindowHorizontal(windowToChange) {
        windowToChange.width /= 2;
      }
      function shrinkWindowVertical(windowToChange) {
        windowToChange.height /= 2;
      }
      function moveWindowLeft(windowToMove) {
        windowToMove.x -= windowToMove.width;
      }
      function moveWindowRight(windowToMove) {
        windowToMove.x += windowToMove.width;
      }
      function moveWindowUp(windowToMove) {
        windowToMove.y -= windowToMove.height;
      }
      function moveWindowDown(windowToMove) {
        windowToMove.y += windowToMove.height;
      }
      function openWindow(x, y) {
        var window = new Window(
          x,
          y,
          DEFAULT_WINDOW_SIZE.width,
          DEFAULT_WINDOW_SIZE.height
        );
        windows[window.id] = window;
        toggleSelected(window);
      }
      function closeWindow(windowToClose) {
        if (selected === windowToClose) selected = null;
        delete windows[windowToClose.id];
        windowToClose.destroy();
      }
    </script>
  </body>
</html>
